ExamCoach Mobile App (Android & iOS) — Low‑Level Technical Specification (LLD) • Replit‑Ready

Version: 1.0Date: 17 Aug 2025

This LLD replaces the WhatsApp-first design with a mobile app for Android & iOS, while re‑using the same backend (Node/TS) and question bank. It’s written to be copy‑pasteable into a repo and workable alongside a Replit‑hosted backend. Where mobile builds are required (APK/IPA), use local machines or CI (GitHub Actions/Codemagic); Replit continues to host the backend APIs.

0) System Architecture (High Level)

Mobile client (Flutter): single codebase → Android & iOS builds. Offline‑first using SQLite. Push via FCM/APNs.

Backend (existing/hosted on Replit): Node/TS (Express + Postgres/SQLite dev). Provides auth, content, AI generation endpoints, payments webhooks, analytics.

AI microservice: RAG + generation + validation (server‑side). App consumes validated questions (no on‑device generation).

Payments: Android → Paystack/Flutterwave web checkout; iOS → Apple IAP (StoreKit). Server stores entitlements for both.

1) Tech Stack

Framework: Flutter 3.x, Dart (sound null safety)

State: Riverpod (hooks_riverpod), immutable models (freezed)

Routing: go_router (deep links supported)

HTTP: dio (+ interceptors)

Local DB: drift (SQLite) + sqlite3_flutter_libs

Storage: shared_preferences for small flags

Background: workmanager (Android), background_fetch (iOS) for pack updates

Push: Firebase Messaging (FCM) + APNs on iOS

Analytics: Firebase Analytics (or Amplitude)

Crash: Sentry (optional)

Charts: fl_chart

React Native is also viable; this LLD targets Flutter for speed and offline ergonomics. Ask if you prefer RN.

2) Monorepo Layout (client + server)

examcoach/
├─ app/                      # Flutter mobile app
│  ├─ pubspec.yaml
│  ├─ lib/
│  │  ├─ app.dart
│  │  ├─ core/               # env, theme, router, utils
│  │  ├─ data/               # dio client, repositories, dtos
│  │  ├─ domain/             # entities, usecases
│  │  ├─ features/
│  │  │  ├─ auth/
│  │  │  ├─ catalog/
│  │  │  ├─ practice/
│  │  │  ├─ mock/
│  │  │  ├─ results/
│  │  │  ├─ downloads/       # offline packs
│  │  │  ├─ billing/
│  │  │  └─ settings/
│  │  ├─ services/           # push, deep_links, connectivity
│  │  └─ widgets/
│  ├─ android/               # generated by flutter create
│  ├─ ios/
│  └─ assets/
└─ server/                   # Your Node backend (can live on Replit)

3) Flutter Dependencies (pubspec.yaml excerpt)

name: examcoach_app
environment:
  sdk: ">=3.4.0 <4.0.0"
dependencies:
  flutter: { sdk: flutter }
  cupertino_icons: ^1.0.6
  hooks_riverpod: ^2.5.1
  go_router: ^14.2.0
  dio: ^5.5.0
  freezed_annotation: ^2.4.4
  json_annotation: ^4.9.0
  drift: ^2.18.0
  sqlite3_flutter_libs: ^0.5.24
  path_provider: ^2.1.4
  shared_preferences: ^2.2.3
  flutter_local_notifications: ^17.2.1
  firebase_core: ^3.4.0
  firebase_messaging: ^15.1.0
  firebase_analytics: ^11.3.3
  fl_chart: ^0.68.0
  url_launcher: ^6.3.0
  package_info_plus: ^8.0.1
  connectivity_plus: ^6.0.3
  uni_links: ^0.5.1
  webview_flutter: ^4.8.0
  in_app_purchase: ^3.2.0

dev_dependencies:
  flutter_test: { sdk: flutter }
  build_runner: ^2.4.11
  freezed: ^2.5.7
  json_serializable: ^6.8.0
  drift_dev: ^2.18.0

4) App Environment & Config

Create lib/core/env/env.dart (replace URLs with your Replit backend):

class Env {
  static const apiBase = String.fromEnvironment('API_BASE_URL', defaultValue: 'https://<replit-backend>.repl.co');
  static const sentryDsn = String.fromEnvironment('SENTRY_DSN', defaultValue: '');
  static const flavor = String.fromEnvironment('FLAVOR', defaultValue: 'dev');
}

Pass values at build time, e.g.: --dart-define=API_BASE_URL=https://...

Firebase setup: add google-services.json (Android) and GoogleService-Info.plist (iOS). Enable Messaging & Analytics.

5) Data Model (Local DB with Drift)

Tables

packs: downloaded question packs metadata

questions: question records (from packs)

sessions: practice/mock sessions

attempts: per-question attempts

topic_stats: local mastery tracking

entitlements: cached subscription state

// lib/data/db/schema.dart (drift)
import 'package:drift/drift.dart';

class Packs extends Table {
  TextColumn get id => text()();
  TextColumn get subject => text()();
  TextColumn get topic => text()();
  IntColumn get version => integer()();
  IntColumn get sizeBytes => integer().withDefault(const Constant(0))();
  DateTimeColumn get installedAt => dateTime().nullable()();
  @override Set<Column> get primaryKey => {id};
}

class Questions extends Table {
  TextColumn get id => text()();
  TextColumn get packId => text()();
  TextColumn get stem => text()();
  TextColumn get a => text()();
  TextColumn get b => text()();
  TextColumn get c => text()();
  TextColumn get d => text()();
  TextColumn get correct => text()();
  TextColumn get explanation => text()();
  IntColumn get difficulty => integer().withDefault(const Constant(2))();
  TextColumn get syllabusNode => text()();
  @override Set<Column> get primaryKey => {id};
}

class Sessions extends Table {
  TextColumn get id => text()();
  TextColumn get mode => text()(); // practice | mock
  TextColumn get subject => text()();
  TextColumn get topic => text().nullable()();
  DateTimeColumn get startedAt => dateTime()();
  DateTimeColumn get endedAt => dateTime().nullable()();
  IntColumn get score => integer().nullable()();
  TextColumn get metaJson => text().nullable()();
  @override Set<Column> get primaryKey => {id};
}

class Attempts extends Table {
  TextColumn get id => text()();
  TextColumn get sessionId => text()();
  TextColumn get questionId => text()();
  TextColumn get chosen => text()();
  BoolColumn get correct => boolean()();
  IntColumn get timeMs => integer()();
  DateTimeColumn get createdAt => dateTime()();
  @override Set<Column> get primaryKey => {id};
}

class TopicStats extends Table {
  TextColumn get topic => text()();
  IntColumn get attempts => integer().withDefault(const Constant(0))();
  IntColumn get correct => integer().withDefault(const Constant(0))();
  RealColumn get accuracy => real().withDefault(const Constant(0))();
  DateTimeColumn get lastSeenAt => dateTime().nullable()();
  @override Set<Column> get primaryKey => {topic};
}

class Entitlements extends Table {
  TextColumn get plan => text()();
  DateTimeColumn get startAt => dateTime()();
  DateTimeColumn get endAt => dateTime()();
  TextColumn get source => text()(); // paystack | flutterwave | apple_iap
  @override Set<Column> get primaryKey => {plan, startAt};
}

6) API Contracts (App ↔ Backend)

Auth

POST /auth/otp/start → { phone }

POST /auth/otp/verify → { phone, code } → { token, user }

Catalog

GET /subjects → [{ id, name }]

GET /syllabus/:subject → [{ node_id, name, parent_node_id, objectives[] }]

Packs

GET /packs/manifest?subject=ENG&since_version=12 → { packs: [{ id, subject, topic, version, size_bytes, checksum }] }

GET /packs/:id → binary zip (JSON + media). Client installs into packs + questions tables.

Practice/Mock

POST /sessions → { mode, subject, topic?, count } → { session_id, items:[{question_id}...] }

POST /attempts/batch → { session_id, attempts:[{question_id, chosen, correct, time_ms}] }

POST /sessions/:id/submit → { score, breakdown_by_topic }

Entitlements/Payments

GET /me/entitlements → { active: true, plan, end_at }

POST /payments/init (Android/Web) → { plan } → { checkout_url }

POST /iap/ios/verify → { app_store_receipt } → { active: true, plan, end_at }

AI (server‑side only)

App does not call AI; it only consumes packs and session items from backend.

7) Core App Flows

Onboarding

Phone OTP login → token stored securely.

Choose subjects (Use of English + 3 others).

Download starter packs (e.g., ENG 200 Qs) on Wi‑Fi.

Practice

Subject → Topic → #Qs → load from local DB → per‑item feedback → end screen with score & weak topics.

Mock (CBT)

60 Qs / 60 min → timer persists across restarts → palette (navigate, flag) → review flagged → submit → results.

Downloads (packs)

Show available updates; fetch diff by version; respect data saver; schedule background fetch on Wi‑Fi + charging.

Billing

Android: open Paystack/Flutterwave checkout in Custom Tabs/WebView → server webhook grants entitlement → app polls GET /me/entitlements or receives push.

iOS: use in_app_purchase → get receipt → POST /iap/ios/verify → entitlement.

Push & Deep Links

Daily reminders → open Practice or Mock directly via examcoach://practice/ENG.

8) UI & Navigation (go_router)

Routes (names → screens):

/welcome, /otp, /subjects, /home, /practice/:subject/:topic?, /mock/:subject, /results/:sessionId, /downloads, /billing, /settings

Key widgets:

QuestionCard (stem + options + next)

TimerBar (mock)

PaletteGrid (mock navigation)

ResultCharts (fl_chart)

9) State Management (Riverpod)

Providers:

authProvider (token, user)

packRepoProvider (manifest + downloads)

sessionProvider (current session, timer)

attemptsProvider (buffer unsynced attempts)

entitlementProvider (plan state)

connectivityProvider (online/offline)

Rules:

Buffer attempts offline → batch sync on connectivity regain.

Guard screens by entitlementProvider.active.

10) Payments Flows (Detailed)

Android (Paystack/Flutterwave)

Tap plan → call POST /payments/init → get checkout_url.

Open Custom Tab; on success, provider redirects to your redirect_url.

Server verifies via webhook → marks subscription active.

App polls GET /me/entitlements every 3s (max 30s) or receives push → unlock.

iOS (Apple IAP)

Load products via in_app_purchase (SKUs: monthly, term, annual).

Purchase → obtain receipt (transaction).

Send to server POST /iap/ios/verify for validation (App Store server → backend).

On success → server updates entitlement → app refreshes.

Do not show Paystack/FLW inside iOS app for digital access to avoid App Store rejection. Use IAP.

11) Offline Pack Format

Manifest (JSON)

{
  "packs": [
    {"id":"ENG-CONCORD-v12","subject":"ENG","topic":"Concord","version":12,"size_bytes":148322,"checksum":"sha256:..."}
  ]
}

Pack ZIP

pack.json
media/

pack.json

{
  "id":"ENG-CONCORD-v12",
  "subject":"ENG",
  "topic":"Concord",
  "version":12,
  "items":[
    {
      "id":"ENG-CONC-0001",
      "stem":"Choose the correct option to complete the sentence…",
      "options":{"A":"…","B":"…","C":"…","D":"…"},
      "correct":"B",
      "explanation":"Subject and verb must agree…",
      "difficulty":2,
      "syllabus_node":"ENG-GRAM-01"
    }
  ]
}

Install algorithm:

Download ZIP → verify checksum → unpack to app dir → insert into packs and questions.

Maintain Bloom filter to avoid repeats within 90 days.

12) Adaptive Logic (Client‑side minimal)

Use topic_stats to bias selection: if accuracy < 50% → prefer easier items (difficulty 1–2); if >70% → harder (3–4).

Spaced repetition: resurface missed items at +1, +3, +7 days using a small queue table (or tag in attempts).

Server remains source of truth for long‑term mastery; client applies light heuristics offline.

13) Notifications & Deep Links

Payload example (FCM)

{
  "to":"<device_token>",
  "notification":{"title":"Daily English practice","body":"7 questions ready"},
  "data":{"route":"/practice/ENG","deeplink":"examcoach://practice/ENG"}
}

Handle in app: if foreground → in‑app banner; if background → route on open.

14) Analytics Events (minimum)

auth_login_success

pack_install_success / pack_install_fail

start_session (mode, subject, topic, count)

submit_item (correct, time_ms, difficulty)

complete_session (score, duration)

buy_plan_click / buy_plan_success

streak_increment / streak_broken

15) Error Handling & Resilience

Global dio interceptor: retries (exponential), offline cache, auth token refresh.

Guard heavy calls behind connectivity checks; queue writes (attempts) until online.

Timer persists to disk (mock) every 5s; on crash, session resumes.

Circuit breaker for backend outages: app switches to offline practice only, with banner.

16) Security

Store auth token in secure storage (Keychain/Keystore) if feasible; fallback shared_prefs minimal risk.

Pin API domain if possible (TLS cert pinning optional).

iOS: comply with ATS; Android: target latest SDK, export rules in manifest.

Do not persist receipts or secrets in logs.

17) Build & CI

Android: keystore in GitHub Actions secrets; build with flutter build appbundle. Upload to Play Console.

iOS: use Codemagic or GitHub Actions + macOS runner; flutter build ipa. Set up App Store Connect, certificates, and IAP products.

Env per flavor: dev/stage/prod via --dart-define and separate Firebase projects.

18) Replit Integration (Dev workflow)

Host backend on Replit (your Node API from prior LLD). Set CORS to allow app domain (for web dev) and accept mobile requests.

For quick UI/dev, run Flutter web locally or in Codespaces; mobile builds require Android Studio/Xcode or CI.

Point API_BASE_URL to the Replit URL; test end‑to‑end auth → packs → sessions.

19) Acceptance Criteria (Mobile MVP)

Login with phone OTP; select subjects; download starter pack under 2 MB.

Start Practice (10 Qs); per‑item feedback; completion screen with score & weak topics.

Start Mock (60 Q/60 min); timer/ palette/ flag/ review; autosubmit on timeout; resume after kill.

Payments: Android Paystack/FLW → entitlement active ≤ 10s post‑webhook. iOS IAP flow verified via Sandbox.

Push: Daily reminder opens Practice route (deep link) reliably.

Offline: Airplane mode still allows Practice using installed packs; attempts sync later.

20) Next Add‑ons

Rich explanations with images/formulas (LaTeX rendering via flutter_math_fork).

Cohort mode and leaderboards (opt‑in username).

Tutor portal (web) with cohort analytics.

AI‑generated hints in‑app (served from backend).

Download manager with per‑subject auto‑update windows.

